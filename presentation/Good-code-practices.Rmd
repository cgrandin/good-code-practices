---
title: "Good Code Practices"
subtitle: "with a focus on R"
author: "Chris Grandin"
institute: "DFO"
date: "Slides compiled on `r Sys.Date()`"
output:
  xaringan::moon_reader:
    css: ["xaringan-themer.css", "inline-code.css", "code-custom.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: 16:9
header-includes:
  - \usepackage{animate}

---
class: inverse

background-image: url(img/obi-wan.jpg)
background-size: contain

```{r setup, include=FALSE, echo=FALSE, fig.width=8, fig.height=8}
# paste this into the console before running `xaringan::inf_mr("twg_01.Rmd")`
# to make your entries faster (fraction of a second)
# options(servr.interval = 0.1)

fig_asp <- 0.618
fig_width <- 9
fig_out_width <- "6in"
fig_dpi <- 180
fig_align <- "center"
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = TRUE,
  comment = "#>",
  fig.asp = fig_asp,
  fig.width = fig_width,
  fig.path = "_bookdown_files/knitr-cache/",
  cache.path = "_bookdown_files/knitr-cache/",
  echo = FALSE,
  cache.comments = FALSE,
  dev = "png",
  dpi = fig_dpi,
  fig.align = fig_align
)

options(htmltools.dir.version = FALSE)
library(dplyr)
library(ggplot2)
library(gfplot)

ggplot2::theme_set(theme_pbs())
```

```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)
style_mono_accent(
  #base_color = "#1c5253",# Matte green
  base_color = "#0B83B7", # Sky blue
  #base_color = "#cc6600ff", # Fall orange
  header_font_google = google_font("Josefin Sans"),
  text_font_google   = google_font("Montserrat", "300", "300i"),
  code_font_google   = google_font("Fira Mono")
)
```

---
class: left

### Motivation

- Many of us are self-taught in computer coding

- Probably all have some bad habits which we could get away with in the past

- But now we share and collaborate on code a lot more (especially through
  GitHub)

  - bad habits can be annoying for collaborators

  - bad habits can be annoying for your future self

  - bad habits lead to wide eyes staring at space (E. Sheeran, respected programmer )
```{r ed, echo = FALSE, eval = TRUE, out.width = 100}
knitr::include_graphics("img/ed.jpg")
```

---
class: left

### Motivation

Things I figured out over the years

- help others and your future self: README files and documenting code

- setting up workflow (having organised folders)

- defining variables just once in code

- never use `T` and `F` for `TRUE` and `FALSE` -- took me a few hours of
    debugging once to learn this one

- it is often worth simplifying some code to make it more efficient (not that I
  always do)

- had previously thought you're fine to just use `=` instead of `<-`. Oops -- not any more
  (sorry!)

- working closely with Chris on Pacific Hake stock assessment has helped my
  coding habits, so thought it worth him sharing some best practices

- this is for TESA, and most stock assessment scientists are using R, so we'll
focus on R, but some tips are applicable for other languages

---
class: center, middle, inverse

# Compilation vs. Interpretation

---
class: left

### Compilation vs Interpretation

#### Compilation

- A compiler takes some code written in a language and generates an executable file that can be run on a particular CPU

- Compilation enforces strong typing which means you must define exactly what type a function's arguments must be and what type is returned

- Examples of compiled languages are C++ and Fortran

#### Interpretation

- An interpreter "*compiles*" code line-by-line at run time

- Interpreted code is usually platform-independent / compiled code needs to be compiled for a specific CPU

- Examples of interpreted languages are Python, Perl, Lisp, and R

---
class: center, middle, inverse

# Paths and file organization

> "If the first line of your R script is"
>
> `setwd("C:\Users\me\path\only\I\have")`
>
> "I will come into your office and SET YOUR COMPUTER ON FIRE"
>
> "If the first line of your R script is"
>
> `rm(list = ls())`
>
> "I will come into your office and SET YOUR COMPUTER ON FIRE"
>
> `r tufte::quote_footer('- Jenny Bryan')`

---
class: left

### Directory structure - using `here::here()`

- To avoid this: `r emo::ji("fire")` `setwd("C:\Users\me\path\only\I\have")` `r emo::ji("fire")`

- Make everything in your project relative to a root project directory

- Use `here::here()`

- Example:
    - If you have data in file called `mydata.csv` somewhere on your computer, create a `data` directory as a subdirectory of your project directory and place `mydata.csv` in there

    - *Anywhere* in your project code, reference that `data` directory like this: `here::here("data")`

--

```{r, mydata, results = 'asis', echo = TRUE}
message(getwd())
data_fn <- here::here("data", "mydata.csv")
message(data_fn)
d <- read.csv(data_fn)
knitr::kable(d)
```

---
class: left

### Directory structure - how `here::here()` works

```{r dir-structure-pic, echo = FALSE, eval = TRUE, out.width = 300}
knitr::include_graphics("img/directory-structure-showing-here.jpg")
```
- If you want to see what the project's root directory is and why it was chosen, run the `here::dr_here()` function:
```{r dr-here, echo = TRUE}
here::dr_here()
```

---
class: left

### Changing directories in code

- Your code should *NEVER* contain the `setwd()` command

```{r, never-setwd, echo = TRUE, error = TRUE}
message(getwd())
setwd("d:/github/main/good-code-practices")
d <- read.csv(file.path("data", "mydata.csv"))
message(getwd())
```

- It's a good bet that nobody else will be able to get the code to work
  - the above code fails on Andy's computer and gives a warning

- It probably won't work on your next machine either


---
class: left

### Creating paths to directories and files

- In Windows, don't use double-backslashes for paths, this removes platform-independence and
  R has evolved way past needing this. For example, you *can* define a path like this for Windows:
```r
path <- "github\\main\\project"
```

- Instead, define it with forward slashes regardless of which OS you are on:
```r
path <- "github/main/project"
```

- Or better yet, for complete platform-independence use `file.path()`:
```{r, file-path, echo = TRUE}
file.path("github", "main", "project")
```

- Notice that that command has the same syntax as `here::here()`:
```{r, here-here-similar-to-file-path, echo = TRUE}
here::here("github", "main", "project")
```

---
class: left

### File naming standards

- R code file names should end in .R

- File should be named with small letters only with words separated by dashes or underscored. eg.
  `utilities.R`, `plot-biomass.R`, `table-decisions.R`, `load-model-files.R`
- R source files should contain one function and the filename should be the same
  as the function name except with dashes as separators instead of underscores

  eg. file `plot-biomass.R` contains one function called `plot_biomass()`

- Exceptions to the one-file-rule are files like `utilities.R` which have small
  utility functions that each fit on one screen

```{r r-source-filenames-pic, echo = FALSE, eval = TRUE, out.width = 300}
knitr::include_graphics("img/r-source-filenames.jpg")
```

---
class: center, middle, inverse, bg_fir

# Variable naming and organization

> "There are only two hard things in Computer Science: cache invalidation and naming things."

-- Phil Karlton

> "There are only two hard things in Computer Science: cache invalidation, naming things, and off-by-one errors"

-- Unknown


---
class: left

### Variable naming standards

- Standards apply to names for all functions, variables, and columns in data frames
- Use **snake case** in R
  - snake_case - `spatial_area` (Python variable names, R names)
- Some different standards include:
  - flatcase - `spatialarea` (Java package names)
  - CapitalCamelCase - `SpatialArea` (C++ names, Java class names)
  - lowerCamelCase - `spatialArea` (Java variable names)
  - UPPER_SNAKE_CASE - `SPATIAL_AREA` (Constants in many languages)
  - dotted.case - `spatial.area` (Some base R functions)
- The worst thing to do is some combination of styles eg. `spatial_AREA.newvar`


---
class: left

### Base R has inconsistent naming

- Base R functions use different standards including dotted, snake case, camel case, upper camel case,
  and flat case. These are sometimes even mixed up in a single function.

- This is a major oversight and confusing for everyone

- The **data.frame()** function has arguments with two different types of naming syntax and a
  function call with a different syntax:
--
```{r data-frame-ex, echo=TRUE, size="tiny"}
data.frame
```

---
class: center

### Don't use dotted names

.left[
- If you come from other languages, the dot typically means that what is to the left is a class and
  what is to the right is a method of that class (C++, Java) so this is very confusing for those people.
  eg. in C++: `string.size()`, in Java: `Socket.connect()`
- **Dotted syntax in R is supposed to be used to denote a custom function for a class**
]
--
.pull-left[.left[
```{r dotted-syntax, echo = TRUE, fig.show = "hide"}
a <- 1:10
par(mar = c(2, 2, 0, 0))
plot(a, type = "l", lwd = 3, col = "blue")
```
]]
.pull-right[.left[
```{r plot-dotted-syntax, ref.label="dotted-syntax", out.height = 125}
```
]]
--
.pull-left[.left[
```{r dotted-syntax-2, echo = TRUE, fig.show = "hide"}
b <- 1:10
class(b) <- c(class(b), "revseries")
plot.revseries <- function(d, ...){
  plot.default(rev(d), ...)
}
par(mar = c(2, 2, 0, 0))
plot(b, type = "l", lwd = 3, col = "blue")
```
]]
.pull-right[.left[
```{r plot-dotted-syntax-2, ref.label="dotted-syntax-2", out.height = 125}
```
]]
.pull-left[.left[
```{r class-check-series, echo = TRUE}
class(b)
```
]]

---
class: left

### Debug session - Appending values to a vector of factors

When you run the following code:

```{r factor-example, echo = TRUE, eval = TRUE}
j <- factor(1:10)
print(j)
print(class(j))


k <- c(j, 11)
print(k)
print(class(k))
```
the result is a numeric vector. But what if you wanted a factor vector
returned instead?

How can you change the definition of `c()` without messing up all the
calls to `c()` for other types?
--
```{r c-factor-default, echo = TRUE, eval = FALSE}
c.factor <- function (..., recursive = TRUE){
  x <- lapply(list(...), function(.x) as.factor(.x))
  y <- unlist(x, recursive = recursive)
  if(inherits(y, "factor") &&
       all(vapply(x, inherits, NA, "ordered")) &&
      (length(unique(lapply(x, levels))) == 1L))
    class(y) <- c("ordered", "factor")
  y
}
```

---
class: center, middle, inverse
# Standardizing your coding style

> "Good coding style is like using correct punctuation. You can manage without it, but it sure makes things easier to read."
>
> `r tufte::quote_footer('- Hadley Wickham')`

---
class: left

### Syntax style standards

We may have to live with the non-adherence of variable naming present in R's base code and that of some package developers, but we can and should follow best practices for variable naming syntax.

For R, this is covered very well in the [Advanced-R style guide](http://adv-r.had.co.nz/Style.html)
and the [Tidyverse style guide](https://style.tidyverse.org/).

The main points are:
- Use all lowercase letters for variable names, with words being separated by underscores.
  Do not use capital letters
- Place spaces around all infix operators (**+**, **-**, **/** , *****, **=**, **,**, **%in%**).
  This includes before indices in array indexing, e.g `dat[1, , 2]`, `arr_x[1, 1, ]`
- Opening brackets of all types should never go on their own lines
- Indent two spaces inside functions, if conditionals, and for loops
- use **<-** for assignment, not **=**
- Place a space before left parenthesis unless it is a function call. I disagree
  with placing spaces after `if`, `for`, and `while` statements

---
class: left

### Syntax style standards

- Here's what the style guide suggests:
```{r if-for-while-spacing, echo = TRUE, eval = FALSE}
if (x >= 0.5) {
 done <- FALSE
 while (!done) {
   for (i in 1:10) {
     print(letters[sample(1:26, i)])
   }
   done <- TRUE
 }
} else {
 print("Lower 50th")
}
```
- Here's how I would write it:
```{r if-for-while-nospacing, echo = TRUE, eval = TRUE}
x <- 0.9
if(x >= 0.5){
  done <- FALSE
  while(!done){
    for(i in 0:4){
      print(letters[c(1, 5, 9, 15, 21) + i])
    }
    done <- TRUE
  }
}else{
  print("Lower 50th")
}
```
- These are just functions with syntactic sugar


---
class: left

### Syntax style standards (2)

Example of good code style:

```{r good-code-style, echo = TRUE, eval = TRUE}
latex_math_bold <- function(txt){
  paste0("$\\mathbf{", txt, "}$")
}

latex_bold <- function(txt){
  paste0("\\textbf{", txt, "}")
}

latex_mlc <- function(latex_vec,
                      make_bold = TRUE,
                      math_bold = FALSE){
  if(make_bold){
    if(math_bold){
      latex_vec <- purrr::map_chr(latex_vec, latex_math_bold)
    }else{
      latex_vec <- purrr::map_chr(latex_vec, latex_bold)
    }
  }
  latex_str <- paste(latex_vec, collapse = " \\\\ ")
  paste0("\\mlc{", latex_str, "}")
}


latex_mlc(c("Coastwide", "Catch", "(tonnes)"))
```

- See **`gfutilities::summarize_quants()`** for a longer example with Roxygen documentation

---
class: left

### Syntax style standards (3)

Note that
- **if()** and **for()** are functions so there should be no space before the left parenthesis
- the argument list has each argument on it's own line. This is easier to read and allows easy commenting-out of individual arguments

---
class: center

### Style suggestions (3)

.left[
Example of good code style using dplyr and pipes (`%>%`) mixed with ggplot and `+`:
]
.pull-left[.left[
```{r good-code-style-pipes, echo = TRUE, eval = FALSE}
library(dplyr)
library(ggplot2)
mtcars %>%
  mutate(am = ifelse(am == 0,
                     "Automatic",
                     "Standard")) %>%
  ggplot(aes(x = am, y = hp)) +
  geom_point() +
  labs(y = "Gross horsepower",
       x = "Transmission")
```
]]
.pull-right[
```{r plot-good-code-style-pipes, ref.label = 'good-code-style-pipes', echo = FALSE}
```
]
.left[
Always place new items piped with `%>%` or added to ggplots with `+` on their own line:
  - Much easier to read
  - Allows them to be commented out easily
  - Less possibility of wrapping code past the end of the window frame

Other functions with multiple arguments should have their arguments on their own lines as well. See the `ifelse()` in the above example.
]

---
class: center, middle, inverse

# Variable Typing

---
class: center

### Variable typing

.left[
In most computer languages, variables are **strongly typed**. Here is an example in C++:

```{r example-string-typing, engine = 'Rcpp', echo = TRUE, eval = FALSE}
#include <iostream>
using namespace std;

double mult(double a, double b){
  double r;
  r = a * b;
  return r;
}

int main (){
  double z;
  z = mult(5, 3);
  cout << "The result is " << z;
}
```
In this code, *ALL* variables are given a datatype that they must adhere to, including the return value from the function.
This makes coding easier, because the compiler will tell you right away if you make a call to the function with an erroneous type.
]

---
class: center

### Variable typing (2)

.left[
In R, variables are **weakly typed**. In addition, R is **interpreted**, not **compiled** so you will not know there is a problem until your code runs to that point

```{r example-string-typing-r, echo = TRUE, eval = TRUE}
#' Multiply two numbers
mult <- function(a, b){
  r <- a * b
  r
}
mult(5, 3)
```
In this code, variables are not typed and they could be anything. If we try to run the code with a different type than intended something possibly unexpected occurs:
```{r mult-data-frame, echo = TRUE, eval = TRUE}
d <- data.frame(j = c(1, 2, 3), k = c(4, 5, 6))
mult(5, d)
```
]

.left[
Or worse:
```{r mult-data-frame-with-chars, echo = TRUE, eval = TRUE, error = TRUE}
d1 <- data.frame(j = c(1, 2, 3), k = c(4, 5, "a"))
mult(5, d1)
```
]

---
class: center

### Variable typing (3)

.left[
Well, maybe that wasn't so bad, but as the author of the function have you thought of what will happen with **every** data type and dimension of those data types? What about this:
```{r mult-mat, echo = TRUE, eval = TRUE, error=TRUE}
k <- data.frame(j = c(1, 2, 3), k = c(4, 5, 6), i = c(10, 11, 12))
mult(d, k)
```

This is obvious here, but when errors like this happen deep inside a function in someone else's package can be very frustrating. It can mean that you have to download the package source and debug the package.

These errors can be caught at the beginning of the function by checking all the variables for correct type and dimension. This is called **Argument verification**
]

---
class: center

---
class: center, middle, inverse

# Promises and the ellipsis argument (...)

---
class: left

### Global variables are bad

- Global variables are not a good idea in any language
  - Any function can read or write to them which means the global state of the
    program can change in many ways at any time
  - As the project complexity increases, keeping track of these changes becomes
    extremely difficult and frustrating
  - Eventually, debugging becomes impossible

- Pass all variables as arguments to functions instead
  - This can be tedious if you are passing variables through multiple functions
    in a chain fashion. eg:
    ```{r chain-passing, echo = TRUE}
      yy <- function(a, b, d){
        paste("yy() has arguments:", a, b, d)
      }
      j <- 1; k <- 2; a <- 3; b <- 4; d <- 5
      xx <- function(j, k, a, b, d){
        paste("xx() has arguments:", j, "and", k, "and", yy(a, b, d))
      }
    ```
---
class: center

### *Promise already under evaluation* error
.left[
Here is an example of some code which will cause a promise error
```{r promise-error, echo = TRUE, eval = TRUE, error = TRUE}
user_power <- function(val, pow){
  val ^ pow
}
power_list <- function(lst, ...){
  purrr::map_dbl(lst, function(list_item = .x, ...){
    user_power(list_item, ...)
  }, ...)
}
power_list(6:9, 3)
```

  This is caused by default arguments being set with the form `j = j` in the function declaration and can be easily fixed by changing the argument name like this
  ```{r fix-promise-error, echo = TRUE, eval = TRUE}
  j <- function(a, b, func){
    a + b
  }
  k <- function(my_j = j, a, b){
    my_j(a, b)
  }
  k(a = 3, b = 4)
  ```
  This can be very difficult to fix properly if you pass these variables through several functions, because you don't want to come up with a new name for the argument in each one. It can get really confusing really fast. The best way to solve this issue is to use the ellipsis argument
]

---
class: center

### Fix promise error with the ellipsis argument
.left[
```{r fix-promise-error-ellipsis, echo = TRUE, eval = TRUE}
j <- function(a, b){
  a + b
}
k <- function(j, ...){
  j(...)
}
k(j = j, a = 3, b = 4)
```

]

---
class: center, middle, inverse

# Avoid using `for()` loops

---
class: center

### `for()` loops should be avoided, use functional forms instead
.left[
Using `for()` loops come naturally to people familiar with procedural programming, and is more intuitive so newcomers to R tend to use them a lot.
```{r for-loop, echo = TRUE, eval = TRUE}
# Cube a vector of numbers
output <- NULL
for(x in 1:10){
  output[x] <- x ^ 3
}
print(output)
```
The same loop using base R's `lapply` method:
```{r sapply-loop, echo = TRUE, eval = TRUE}
unlist(lapply(1:10, function(x){x ^ 3}))
```
The same loop using the package `purrr::map_dbl()` method:
```{r map-loop, echo = TRUE, eval = TRUE}
purrr::map_dbl(1:10, ~{.x ^ 3})
```
The `purrr::map_dbl` method allows use of `~` as a shorthand form for `function(x)` and each list element is assigned to `.x` by `purrr`.
]



---
class: center

### Tibbles
.left[
**tibbles** are just **data.frames** with some special output properties so that viewing them in the console is much nicer. To convert a data frame to a tibble, use `tibble::as_tibble()`.

**tibbles** only show the first ten rows by default so the header doesn't run off the screen, and each column type is shown at the top. Seeing the column type is highly useful! Also, negative numbers are colored red (in RStudio).
```{r convert-to-tibble, echo = TRUE, eval = TRUE}
iris %>% as_tibble()
```
]

---
class: center

### Tibbles (2)
.left[
Making a tibble from scratch is the same as making a `data.frame`. This code makes a tibble of random letters and numbers and plots the distribution of random letters drawn using `ggplot`:
```{r make-tibble, echo = TRUE, eval = TRUE, out.height = 350}
num_rows <- 1000

# tibble::tibble(row = 1:num_rows,
#                number = sample(1:50, num_rows, replace = TRUE),
#                letter = letters[sample(1:26, num_rows, replace = TRUE)]) %>%
#   mutate(number = as.character(number)) %>%
#   tidyr::pivot_longer(cols = c("number", "letter"), names_to = "type", values_to = "value") %>%
#   ggplot2::ggplot(aes(x = value, y = type)) +
#   ggplot2::geom_bar(fill = "#0000FF4D")
```
]

---
class: center

### Using `purrr::map2()`
.left[
One thing that come up quite often is that you have a list of data frames that need the list index number appended to the individual data frames.

One reason this happens is if you have N simulations and you want to append the simulation number to each data frame, and then merge those data frames into one large one so that the data are in the correct format for `ggplot` plots.
```{r fake-sim, echo = TRUE, eval = FALSE}
# Split the mtcars data frame by column `carb` into a list of data frames
lst <- mtcars %>%
  tibble::as_tibble(rownames = "make") %>%
  dplyr::group_by(carb) %>%
  dplyr::group_split()

df <- purrr::map2(lst, seq_along(lst), ~{
  .x %>% dplyr::mutate(group_num = .y)
}) %>%
  purrr::map_df(~{.x})

print(df, n = 100)
```
]

---
class: center

### Using `purrr::map2()`
.left[
```{r table-fake-sim, echo = FALSE, eval = TRUE, ref.label = "fake-sim"}
```
]

---
class: center

### Using `map()` with ellipsis passed to internal functions
.left[
This is a common thing you need to do if you're using the `map()` functions but strangely there are no examples that I could find online for this. Using this method you can pass N arguments into the function which is applied to each element of the list.

```{r map-ellipsis, echo = TRUE, eval = TRUE, error = TRUE}
ultimate_power <- function(val, pow){
  val ^ pow
}
power_list <- function(lst, ...){
  purrr::map_dbl(lst, function(list_item = .x, ...){
    ultimate_power(list_item, ...)
  }, ...)
}
power_list(6:9, 3)
```
]


---
class: center

### Power function is less efficient than multiplying
.left[
Squared operation
```{r power-function-optim, echo = FALSE, eval = TRUE}
loop_len <- 1000
sz <- 100000
a <- sample(1000, size = sz, replace = TRUE)
f <- function (n) for (i in 1:n) d <- a ^ 2
g <- function (n) for (i in 1:n) d <- a * a
system.time(f(loop_len))
system.time(g(loop_len))
```
Cubed operation
```{r power-function-optim-2, echo = FALSE, eval = TRUE}
a <- sample(1000, size = sz, replace = TRUE)
f <- function (n) for (i in 1:n) d <- a ^ 3
g <- function (n) for (i in 1:n) d <- a * a * a
h <- function (n) for (i in 1:n) d <- (a ^ 2) * a
system.time(f(loop_len))
system.time(g(loop_len))
system.time(h(loop_len))
```
Looking at the **user** time, the squared operation is faster than multiplying the number with itself. It is a special case of power which has been optimized in R. For higher degrees of power, it is much faster to use multiplication (7.8x faster) and the squared operation with multiplication (9.6x faster) rather than calculate using the power function (^) itself.
]

---
class: left

# References for images

- [Obi Wan](https://starecat.com/when-you-read-some-incredibly-bad-code-thinking-what-a-moron-wrote-this-but-halfway-through-it-starts-to-become-familiar-obi-wan-kenobi-well-of-course-i-know-him-hes-me)

- [Animated fire](http://clipart-library.com/clipart/n932465.htm)

- [The Matrix](https://en.wikipedia.org/wiki/File:Computer-screen-code-glitch-animation-gif-background-free.gif)

- [Rotating head](https://giphy.com/gifs/hacker-hack-hacking-4OAxDXv4RdUeg38JYi)

---
class: center

# Thank you!

Click the GitHub cat for the source code used to build these slides

<a href="https://github.com/cgrandin/good-code-practices" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
